#!/usr/bin/env python3
"""Quick reader for the binary ``.plane`` files produced by ``plane_output``."""

from __future__ import annotations

import argparse
import os
import struct
from collections import namedtuple

import numpy as np

AxisInfo = namedtuple("AxisInfo", ["name", "fixed_axis", "varying_axes"])
AXIS_INFO = {
    1: AxisInfo(name="yz", fixed_axis="x", varying_axes=("y", "z")),
    2: AxisInfo(name="xz", fixed_axis="y", varying_axes=("x", "z")),
    3: AxisInfo(name="xy", fixed_axis="z", varying_axes=("x", "y")),
}

STRUCT_HEADER = "<iiiidi"  # version, axis_id, n1, n2, coord(double), fixed_index
HEADER_SIZE = struct.calcsize(STRUCT_HEADER)
DOUBLE_SIZE = struct.calcsize("<d")


def parse_args() -> argparse.Namespace | None:
    parser = argparse.ArgumentParser(
        description="Report contents of a .plane file generated by waveqlab3d_main_plane."
    )
    parser.add_argument("planefile", help="path to the .plane file")
    return parser.parse_args()


def read_header(path: str) -> tuple[int, int, int, float, int]:
    with open(path, "rb") as f:
        header = f.read(HEADER_SIZE)
        if len(header) != HEADER_SIZE:
            raise IOError("file is too short to contain a valid header")
    return struct.unpack(STRUCT_HEADER, header)


def main() -> None:
    args = parse_args()
    planefile = args.planefile

    if not os.path.isfile(planefile):
        raise FileNotFoundError(f"{planefile} is not a file")

    version, axis_id, n1, n2, coord, fixed_index = read_header(planefile)
    axis_desc = AXIS_INFO.get(
        axis_id, AxisInfo(name="unknown", fixed_axis="?", varying_axes=("dim1", "dim2"))
    )
    npts = n1 * n2

    record_size = DOUBLE_SIZE + 3 * npts * DOUBLE_SIZE
    filesize = os.path.getsize(planefile)

    if filesize < HEADER_SIZE:
        raise ValueError("file too short to contain header")

    payload_bytes = filesize - HEADER_SIZE
    if payload_bytes % record_size != 0:
        raise ValueError("unexpected file size, does not match an integer number of records")

    nt = payload_bytes // record_size

    min_max = {"vx": [np.inf, -np.inf], "vy": [np.inf, -np.inf], "vz": [np.inf, -np.inf]}
    time_min = np.inf
    time_max = -np.inf

    with open(planefile, "rb") as f:
        f.seek(HEADER_SIZE)
        dtype = np.dtype("<f8")
        count_per_step = 1 + 3 * npts
        for step in range(int(nt)):
            block = np.fromfile(f, dtype=dtype, count=count_per_step)
            if block.size != count_per_step:
                raise EOFError("unexpected EOF while reading snapshot data")

            time = float(block[0])
            time_min = min(time_min, time)
            time_max = max(time_max, time)

            fields = block[1:].reshape(3, npts)
            for label, values in zip(("vx", "vy", "vz"), fields):
                current_min = float(values.min())
                current_max = float(values.max())
                min_max[label][0] = min(min_max[label][0], current_min)
                min_max[label][1] = max(min_max[label][1], current_max)

    print(f"file: {planefile}")
    print(f"version: {version}")
    print(f"axis: {axis_desc.name} (fixed {axis_desc.fixed_axis}, index {fixed_index})")
    dim1_label, dim2_label = axis_desc.varying_axes
    print(f"coord: {coord}")
    print(f"nt: {nt} (time range: {time_min} .. {time_max})")
    print(f"{dim1_label} range: 1 .. {n1}")
    print(f"{dim2_label} range: 1 .. {n2}")
    print(f"nfields: 3 (vx, vy, vz)")
    for label in ("vx", "vy", "vz"):
        lo, hi = min_max[label]
        print(f"{label} min: {lo}, max: {hi}")


if __name__ == "__main__":
    main()
